{
  "author": {
    "name": "Felix Geisend√∂rfer",
    "email": "felix@debuggable.com",
    "url": "http://debuggable.com/"
  },
  "name": "measured",
  "description": "This is an alternative port of Coda Hale's metrics library.",
  "version": "0.1.3",
  "homepage": "https://github.com/felixge/node-measured",
  "repository": {
    "url": "git://github.com/felixge/node-measured.git"
  },
  "main": "./index",
  "scripts": {
    "test": "make test"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {},
  "devDependencies": {
    "urun": "0.0.4",
    "utest": "0.0.3",
    "sinon": "git://github.com/felixge/Sinon.JS.git#stub-prototype-properties"
  },
  "optionalDependencies": {},
  "readme": "# measured\n\n[![Build Status](https://secure.travis-ci.org/felixge/node-measured.png)](http://travis-ci.org/felixge/node-measured)\n\nThis is an alternative port of Coda Hale's [metrics library][codametrics].\n\nI created this despite the existing [metrics port][existingmetrics] for node.js\nto fully understand the underlaying algorithms, and to provide a solid, tested\nand documented module.\n\n[codametrics]:  https://github.com/codahale/metrics\n[existingmetrics]: https://github.com/mikejihbe/metrics\n\n## Install\n\n```\nnpm install measured\n```\n\n## Usage\n\n**Step 1:** Add measurements to your code. For example, lets track the\nrequests/sec of a http server:\n\n```js\nvar http  = require('http');\nvar stats = require('measured').createCollection();\n\nhttp.createServer(function(req, res) {\n  stats.meter('requestsPerSecond').mark();\n  res.end('Thanks');\n}).listen(3000);\n```\n\n**Step 2:** Show the collected measurements (more advanced examples follow later):\n\n```js\nsetInterval(function() {\n  console.log(collection.toJSON());\n}, 1000);\n```\n\nThis will output something like this every second:\n\n```\n{ requestsPerSecond:\n   { mean: 1710.2180279856818,\n     count: 10511,\n     'currentRate': 1941.4893498239829,\n     '1MinuteRate': 168.08263156623656,\n     '5MinuteRate': 34.74630977619571,\n     '15MinuteRate': 11.646507524106095 } }\n```\n\n**Step 3:** Aggregate the data into your backend of choice. I recommend\n[graphite][].\n\n[graphite]: http://graphite.wikidot.com/\n\n## Metrics\n\nThe following metrics are available (both standalone and on the Collection API):\n\n### Gauge\n\nValues that can be read instantly. Example:\n\n```js\nvar gauge = new metrics.Gauge(function() {\n  return process.memoryUsage().rss;\n});\n```\n\nThere is currently no callback support for Gauges because otherwise it would be\nvery difficult to report the metrics inside a collection within a regular\ninterval.\n\n**Options:**\n\n* Gauges take a function as parameter which needs to return their current value.\n\n**Methods:**\n\nNone.\n\n**toJSON Output:**\n\nGauges directly return their currently value.\n\n### Counter\n\nThings that increment or decrement. Example:\n\n```js\nvar activeUploads = new metrics.Counter();\nhttp.createServer(function(req, res) {\n  activeUploads.inc();\n  req.on('end', function() {\n    activeUploads.dec();\n  });\n});\n```\n\n**Options:**\n\n* `count` An initial count for the counter. Defaults to `0`.\n\n**Methods:**\n\n* `inc(n)` Increment the counter by `n`. Defaults to `1`.\n* `dec(n)` Decrement the counter by `n`. Defaults to `1`.\n* `reset(count)` Resets the counter back to `count` Defaults to `0`.\n\n**toJSON Output:**\n\nCounters directly return their currently value.\n\n### Meter\n\nThings that are measured as events / interval. Example:\n\n```js\nvar meter = new metrics.Meter();\nhttp.createServer(function(req, res) {\n  meter.mark();\n});\n```\n\n**Options:**\n\n* `rateUnit` The rate unit. Defaults to `1000` (1 sec).\n* `tickInterval` The interval in which the averages are updated. Defaults to\n  `5000` (5 sec).\n\n**Methods:**\n\n* `mark(n)` Register `n` events as having just occured. Defaults to `1.\n* `reset()` Resets all values. Meters initialized with custom options will\n  be reset to the default settings (patch welcome).\n\n**toJSON Output:**\n\n* `mean`: The average rate since the meter was started.\n* `count`: The total of all values added to the meter.\n* `currentRate`: The rate of the meter since the last toJSON() call.\n* `1MinuteRate`: The rate of the meter biased towards the last 1 minute.\n* `5MinuteRate`: The rate of the meter biased towards the last 5 minutes.\n* `15MinuteRate`: The rate of the meter biased towards the last 15 minutes.\n\n### Histogram\n\nKeeps a resevoir of statistically relevant values biased towards the last 5\nminutes to explore their distribution. Example:\n\n```js\nvar histogram = new metrics.Histogram();\nhttp.createServer(function(req, res) {\n  if (req.headers['content-length']) {\n    histogram.update(parseInt(req.headers['content-length'], 10));\n  }\n});\n```\n\n**Options:**\n\n* `sample` The sample resevoir to use. Defaults to an `ExponentiallyDecayingSample`.\n\n**Methods:**\n\n* `update(value, timestamp)` Pushes `value` into the sample. `timestamp`\n  defaults to `Date.now()`.\n* `reset()` Resets all values. Histograms initialized with custom options will\n  be reset to the default settings (patch welcome).\n\n**toJSON Output:**\n\n* `min`: The lowest observed value.\n* `max`: The highest observed value.\n* `sum`: The sum of all observed values.\n* `variance`: The variance of all observed values.\n* `mean`: The average of all observed values.\n* `stddev`: The stddev of all observed values.\n* `count`: The number of observed values.\n* `median`: 50% of all values in the resevoir are at or below this value.\n* `p75`: See median, 75% percentile.\n* `p95`: See median, 95% percentile.\n* `p99`: See median, 99% percentile.\n* `p999`: See median, 99.9% percentile.\n\n### Timers\n\nTimers are a combination of Meters and Histograms. They measure the rate as\nwell as distribution of scalar events. Since they are frequently used for\ntracking how long certain things take, they expose an API for that:\n\n```js\nvar timer = new metrics.Timer();\nhttp.createServer(function(req, res) {\n  var stopwatch = timer.start();\n  req.on('end', function() {\n    stopwatch.end();\n  });\n});\n```\n\nBut you can also use them as generic histograms that also track the rate of\nevents:\n\n```js\nvar timer = new metrics.Timer();\nhttp.createServer(function(req, res) {\n  if (req.headers['content-length']) {\n    timer.update(parseInt(req.headers['content-length'], 10));\n  }\n});\n```\n\n**Options:**\n\n* `meter` The internal meter to use. Defaults to a new `Meter`.\n* `histogram` The internal histogram to use. Defaults to a new `Histogram`.\n\n**Methods:**\n\n* `start()` Returns a `Stopwatch`.\n* `update(value)` Updates the internal histogram with `value` and marks one\n  event on the internal meter.\n* `reset()` Resets all values. Timers initialized with custom options will\n  be reset to the default settings (patch welcome).\n\n**toJSON Output:**\n\n* `meter`: See Meter toJSON output docs above.\n* `histogram`: See Histogram toJSON output docs above.\n\n## Todo\n\n* Implement flatten() so reporters can use it\n* Implement async gauges\n* Document using this with graphite / zabbix\n\n## License\n\nThis module is licensed under the MIT license.\n",
  "readmeFilename": "Readme.md",
  "_id": "measured@0.1.3",
  "_from": "measured@0.1.3"
}
